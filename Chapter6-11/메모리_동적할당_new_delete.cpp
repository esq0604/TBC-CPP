#include<iostream>

using namespace std;

int main()
{
	//100만개를 디버그를 해보면 오류가난다 .
	// 4백만 바이트의 스택을 사용하는데 크기가 초과하여 일부데이터를
	//힙으로 이동시키라는 메시지를 보여준다.
	//정적으로 할당하는 메모리는 stack에 들어간다. stack은 용량이 작다
	//동적으로 할당되는 메모리는 heep에 들어간다. hepp은 훨씬 크다.
	//따라서 이러한이유때문에 동적할당을 잘 다루는것은 필수적이다.
	//int arr[1000000];

	//os에게 int 하나 사이즈만큼 메모리 달라하는방법
	int var;

	//다른방법도있다 ->	new int; 
	//int 사이즈에 맞춰 메모리를 os에 받아온다음 메모리주소를 우리에게 알려주는것.
	//따라서 포인터로 받아야함.
	int* ptr = new int;
	*ptr = 7; //de-referencing
	
	//포인터로 메모리를 할당하며 동시에 초기화도 할수있다.
	int* ptr2 = new int{ 7 }; //=int* ptr = new int(7) 또한 가능.
	
	cout << ptr2 << endl;
	cout << *ptr2 << endl;

	//더 중요한것은 할당받은 메모리를 os에게 돌려주는것
	//만약, 빅데이터나, 딥러닝 인공지능을 돌리면 컴퓨터 한대로 감당할수 없는 데이터량을 사용함
	//메모리에 컴퓨터데이터가 안들어갈수도있음. 일부데이터로 작업하고 메모리를 돌려줬다
	//다시 메모리를 받아서 데이터를 가져와야할수도 있다.
	//만약, 여러 프로그램들이 데이터를 다 많이쓰고싶다면 동시에 돌릴수가 없음
	//급한애한테 먼저 메모리를 많이줬다가 다시받아와서 다른프로그램에다 메모리를 줄수도있음.
	//os에게 메모리를 돌려주는방법.
	delete ptr2;

	//주의할점 처음할때는 delete ptr을 실해잇키지 않았는데 아무문제없었음.
	//이유는 os가 이 프로그램에게 메모리를 어디있는걸 얼마나 줬는지 기억해서 그렇다.
	//프로그램이 종료됨가 동시에 자동으로 알아서 거둬갔기 때문에 delete ptr을 해주지 않았어도
	//문제가 생기지 않았던것이다. delete ptr을 해주면 os가 알아서 거둬가기전에(프로그램이 끝나기전에)
	//알아서 내가 반납하겠다 라는 의미가 된다.
	

	//delete이후에는 들여다보지도 않는것이 정석,
	//컴파일시 나오는 숫자(00008123)는 의도적으로 visual studio에서 pointer를 
	//delete한 후에청소 해준다함. 우연히 나온숫자가 아니다.
	cout << "after delete" << endl;
	cout << ptr2 << endl;
	//cout << *ptr2 << endl;


	//오류를 방지하는 방법이 몇가지있다.
	//delete후 는 ptr에 nullptr값을넣어줌.
	//nullptr은 포인터가 가지고있는 주소는 쓸모없다, 라고 기록하는것.
	ptr2 = nullptr; 


	//스마트포인터를 배운후에는 스마트포인터를 사용하면된다함.
	//ptr이 지워지지 않고 의미가 있을때만 de-referecing을 하는방법.
	//스마트포인터를 배운후에는 스마트포인터를 사용하면된다함.
	if (ptr2 != nullptr)
	{
		cout << ptr2 << endl;
		cout << *ptr2 << endl;
	}
	

	


	//메모리를 할당받으려했는데 할당받지 못할수도있음. -다른프로그램이 메모리를 다쓰고있어서
	//내가 쓸메모리가 없는상황. 이런 상황에
	//프로그램이 죽어버리게 짜는방법, 죽지않고 살아있다 다른프로그램이 메모리를 다쓸때까지 기다렸다가 
	//다시 메모리를 할당받는방법이 있다 . 이때는 new가 에러를 일으켜도 버텨야할것이다
	//만약에 new가 실패를 한다면 nothrow에 의해 ptr에 nullptr이 대입된다함. 
	int* ptr3 = new(std::nothrow)int{ 7 };
	if (ptr3 != nullptr)
	{
		cout << ptr3 << endl;
		cout << *ptr3 << endl;
	}
	else
	{
		cout << "could not allocate memory" << endl;
	}

	

	int* ptr4 = ptr3;
	
	//ptr4에도 ptr3이 들어있기 때문에 오류가 난다면 똑같이난다.
	//*ptr4를 한다면 오류를 발생시킬것이다.
	//프로그램이 복잡하면 nullptr을 못넣어줄 경우가 종종발생함.
	//1신경을쓰는방법 , 2스마트포인터를 이용해서 덜 걱정스럽게 도와주는방향 도있다.
	//스마트포인터의 단점은 신경을써서 예방하는것보단 속도가 늦어진다.
	delete ptr3;
	ptr3 = nullptr;
	//ptr4 = nullptr;  가장좋은방법 
	



	//메모리누수 memory leek -동적메모리할당시 지우는걸 깜빡
	//메모리를 계속 만들기만 하는것. 쓰지는 않고 os부터 계속받는데 
	//어디있는지 알수도없는경우
	// ptr변수가 계속해서 사라질것임. 컴퓨터 메모리를 다시만날일은 없음
	//만나더라도 그메모리가 이메모리인가 기억할수없음. 
	//프로그램이 작동할때 작업관리자를 보면 메모리가 끊임없이 올라간다면
	//메모리가 누수되고있는것이다. 
	//new와 delete는 os에게 다녀오는것이므로 , 이러한과정은 속도가 좀느리다.
	//new와 delete을 적게사용하는 방식으로 프로그래밍을 하는것이 나중에는 좋다.
	while (true)
	{
		int* ptr = new int;
		cout << ptr << endl;
		
		delete ptr;
	}
	return 0;
}